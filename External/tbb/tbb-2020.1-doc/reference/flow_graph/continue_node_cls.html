
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="DC.Type" content="reference" />
<meta name="DC.Title" content="continue_node Template Class" />
<meta name="DC.subject" content="continue_node Template Class" />
<meta name="keywords" content="continue_node Template Class" />
<meta name="DC.Relation" scheme="URI" content="../../reference/flow_graph/functional_nodes.html" />
<meta name="DC.Relation" scheme="URI" content="make_edge_func.html" />
<meta name="DC.Relation" scheme="URI" content="remove_edge_func.html" />
<meta name="DC.Relation" scheme="URI" content="copy_body_func.html" />
<meta name="DC.Relation" scheme="URI" content="../task_scheduler/task_group_context.html" />
<meta name="DC.Relation" scheme="URI" content="../exceptions.html" />
<meta name="DC.Relation" scheme="URI" content="message_passing_protocol.html" />
<meta name="DC.Relation" scheme="URI" content="sender_and_buffer_policy.html" />
<meta name="DC.Relation" scheme="URI" content="dependency_flow_graph_example.html" />
<meta name="DC.Relation" scheme="URI" content="lightweight_policy.html" />
<meta name="DC.Relation" scheme="URI" content="../appendices/preview_features/flow_graph/helper_functions_for_expressing_graphs.html" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="continue_node_cls" />
<meta name="DC.Language" content="en-US" />
<link rel="stylesheet" type="text/css" href="../../intel_css_styles.css" />
<title>continue_node Template Class</title>
<script src="../../resources/prism/prism.js"><!----></script>
<link href="../../resources/prism/prism.css" rel="stylesheet" />
</head>
<body id="continue_node_cls">
 <!-- ==============(Start:NavScript)================= -->
 <script src="..\..\NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>
 <!-- ==============(End:NavScript)================= -->



  <h1 class="topictitle1">continue_node Template Class</h1>

  
  <div>
    <div class="section"><h2 class="sectiontitle">Summary</h2>
      
      <p>
        A template class that is a <span class="keyword">graph_node</span>,
        <span class="keyword">continue_receiver</span> and a <span class="keyword">sender&lt;T&gt;</span>. It executes
        a specified body object when triggered and broadcasts the generated value to all of its
        successors.
      </p>

    </div>

    <div class="section"><h2 class="sectiontitle">Syntax</h2>
      
<pre>
template&lt; typename Output, typename Policy = void &gt;
class continue_node;
</pre>
    </div>

    <div class="section"><h2 class="sectiontitle">Header</h2>
      
      <pre>#include "tbb/flow_graph.h"</pre>
    </div>

    <div class="section"><h2 class="sectiontitle">Description</h2>
      
      <p>
        This type is used for nodes that wait for their predecessors to complete before executing,
        but no explicit data is passed across the incoming edges. The output of the node can be a
        <span class="keyword">continue_msg</span> or a value.
      </p>

      <p>
        A <span class="keyword">continue_node</span> maintains an internal threshold, T, and an internal
        counter, C. If a value for the number of predecessors is provided at construction, then T is
        set to the provided value and C=0.  Otherwise, C=T=0.
      </p>

      <p>
        At each call to method <span class="keyword">register_predecessor</span>, the threshold T is
        incremented. At each call to method <span class="keyword">remove_predecessor</span>, the threshold T
        is decremented.  The functions <span class="keyword">make_edge</span> and
        <span class="keyword">remove_edge</span> appropriately call <span class="keyword">register_predecessor</span>
        and <span class="keyword">remove_predecessor</span> when edges are added to or removed from a
        <span class="keyword">continue_node.</span>
      </p>

      <p>
        At each call to method <span class="keyword">try_put</span>, C is incremented. If after the increment,
        C&gt;=T, then C is reset to 0 and a task is spawned to broadcast the result of
        <span class="keyword">body()</span> to all successors. The increment of C, spawning of the task, and
        the resetting of C are all done atomically with respect to the node. If after the increment,
        C&lt;T, no additional action is taken.
      </p>

      <p>
        The value generated by an execution of the body object is broadcast to all
        successors. Rejection of messages by successors is handled using the protocol described in
        the Message Passing Protocol.
      </p>

      <p>
        A <span class="keyword">continue_node</span> can serve as a terminal node in the graph. The convention
        is to use an <span class="keyword">Output</span> of <span class="keyword">continue_msg</span> and attach no
        successor.
      </p>

      <p><span class="keyword">Output</span> must be copy-constructible and assignable.</p>

      <p>The Body concept for <span class="keyword">continue_node</span> is shown in below.</p>

      
<div class="tablenoborder"><table cellpadding="4" summary="" id="tbl22" frame="border" border="1" cellspacing="0" rules="all"><caption><span class="tablecap">continue_node&lt;Output&gt; Body Concept</span></caption>
          
          
          <thead align="left">
            <tr>
              <th class="cellrowborder" align="center" valign="top" width="50%" id="d70557e149"><p>Pseudo-Signature</p>
</th>

              <th class="cellrowborder" align="center" valign="top" width="50%" id="d70557e153"><p>Semantics</p>
</th>

            </tr>

          </thead>

          <tbody>
            <tr>
              <td class="cellrowborder" valign="top" width="50%" headers="d70557e149 ">
                <p><span class="keyword">B::B( const B&amp; )</span></p>

              </td>

              <td class="cellrowborder" valign="top" width="50%" headers="d70557e153 "><p>Copy constructor.</p>
</td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="50%" headers="d70557e149 ">
                <p><span class="keyword">B::~B()</span></p>

              </td>

              <td class="cellrowborder" valign="top" width="50%" headers="d70557e153 "><p>Destructor.</p>
</td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="50%" headers="d70557e149 "><p><span class="keyword">void operator=( const B&amp; )</span></p>
</td>

              <td class="cellrowborder" valign="top" width="50%" headers="d70557e153 ">
                <p>
                  Assignment. The return type <span class="keyword">void</span> in the pseudo-signature
                  denotes that <span class="keyword">operator=</span> is not required to return a value.  The
                  actual <span class="keyword">operator=</span> can return a value, which will be ignored.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="50%" headers="d70557e149 ">
                <p><span class="keyword">Output B::operator()(const continue_msg &amp;v) const</span></p>

              </td>

              <td class="cellrowborder" valign="top" width="50%" headers="d70557e153 "><p>Perform operation and return value of type Output.</p>
</td>

            </tr>

          </tbody>

        </table>
</div>

      <div class="Note"><h3 class="NoteTipHead">CAUTION</h3> 
        <p>
          The body object passed to a <span class="keyword">continue_node</span> is copied. Therefore updates
          to member variables will not affect the original object used to construct the node. If the
          state held within a body object must be inspected from outside of the node, the
          <span class="keyword">copy_body</span> function can be used to obtain an updated copy.
        </p>

      </div>

      <div class="Note"><h3 class="NoteTipHead">Note</h3> 
        <p>
          The body object may throw or cancel its enclosing graph. See task_group_context and
          Exceptions sections for a description.
        </p>

      </div>

    </div>

    <div class="section"><h2 class="sectiontitle">Example</h2>
      
      <p>
        A set of <samp class="codeph">continue_nodes</samp> forms a
        <a href="dependency_flow_graph_example.html">
          Dependency Flow Graph
          </a>.
      </p>

    </div>

    <div class="section"><h2 class="sectiontitle">Members</h2>
      
      <pre>
namespace tbb {
namespace flow {

template&lt; typename Output &gt;
class continue_node :
  public graph_node, public continue_receiver, public sender&lt;Output&gt; {
public:
    template&lt;typename Body&gt;
    continue_node( graph &amp;g, Body body );
    template&lt;typename Body&gt;
    continue_node( graph &amp;g, int number_of_predecessors,
    Body body );
    continue_node( const continue_node &amp;src );

    // continue_receiver
    typedef continue_msg input_type;
    typedef sender&lt;input_type&gt; predecessor_type;
    bool try_put( const input_type &amp;v );
    bool register_predecessor( predecessor_type &amp;p );
    bool remove_predecessor( predecessor_type &amp;p );

    // sender&lt;Output&gt;
    typedef Output output_type;
    typedef receiver&lt;output_type&gt; successor_type;
    bool register_successor( successor_type &amp;r );
    bool remove_successor( successor_type &amp;r );
    bool try_get( output_type &amp;v );
    bool try_reserve( output_type &amp;v );
    bool try_release( );
    bool try_consume( );
};

}
}</pre>
      
<div class="tablenoborder"><table cellpadding="4" summary="" frame="border" border="1" cellspacing="0" rules="all"><span class="tabledesc">
          The following table provides additional information on the members of this template class.
        </span>
          
          <thead align="left">
          <tr>
            <th class="cellrowborder" valign="top" width="33.89830508474576%" id="d70557e288">Member</th>

            <th class="cellrowborder" valign="top" width="66.10169491525423%" id="d70557e291">Description</th>

          </tr>

        </thead>

        <tbody>
          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">template&lt; typename Body&gt; continue_node( graph &amp;g, Body body )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                Constructs a <span class="keyword">continue_node</span> that will invoke
                <span class="keyword">body</span>.
              </p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">template&lt; typename Body&gt; continue_node( graph &amp;g, Body body, Policy = Policy() )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                The constructor works the same as the previous one, but allows to specify a policy.
              </p>

              <div class="Note"><h3 class="NoteTipHead">Note</h3> 
                The constructor requires C++11-compliant compiler.
              </div>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">
                template&lt; typename Body&gt;
                continue_node( graph &amp;g, int number_of_predecessors, Body body )
              </span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                Constructs a <span class="keyword">continue_node</span> that will invoke
                <span class="keyword">body</span>. The threshold T is initialized to
                <span class="keyword">number_of_predecessors</span>.
              </p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">
                template&lt; typename Body&gt;
                continue_node( graph &amp;g, int number_of_predecessors, Body body, Policy = Policy() )
              </span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                The constructor works the same as the previous one, but allows to specify a policy.
              </p>

              <div class="Note"><h3 class="NoteTipHead">Note</h3> 
                The constructor requires C++11-compliant compiler.
              </div>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">continue_node( const continue_node &amp;src )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                Constructs a <span class="keyword">continue_node</span> that has the same initial state that
                <span class="keyword">src</span> had after its construction. It does not copy the current
                count of <span class="keyword">try_puts</span> received, or the current known number of
                predecessors. The <span class="keyword">continue_node</span> that is constructed will have a
                reference to the same <span class="keyword">graph</span> object as <span class="keyword">src</span>,
                have a copy of the initial <span class="keyword">body</span> used by <span class="keyword">src</span>,
                and only have a non-zero threshold if <span class="keyword">src</span> was constructed with a
                non-zero threshold.
              </p>

              <div class="Note"><h3 class="NoteTipHead">CAUTION</h3> 
                <p>
                  The new body object is copy-constructed from a copy of the original body provided
                  to <span class="keyword">src</span> at its construction. Therefore changes made to member
                  variables in <span class="keyword">src</span>'s body after the construction of
                  <span class="keyword">src</span> will not affect the body of the new
                  <span class="keyword">continue_node</span>.
                </p>

              </div>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool try_put( const input_type &amp;v )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                Increments the count of <span class="keyword">try_put</span> calls received. If the
                incremented count is equal to the number of known predecessors, a task is spawned to
                execute the <span class="keyword">body</span> and the internal count of
                <span class="keyword">try_put</span> calls is reset to zero. This method performs as if the
                spawning of the body task and the updates to the internal count occur atomically. It
                does not wait for the execution of the body to complete.
              </p>

              <p><strong>Returns</strong>: <span class="keyword">true</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool register_predecessor( predecessor_type &amp;p )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>Increments the number of known predecessors.</p>

              <p><strong>Returns</strong>: <span class="keyword">true</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool remove_predecessor( predecessor_type &amp;p ) </span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>Decrements the number of known predecessors.</p>

              <div class="Note"><h3 class="NoteTipHead">CAUTION</h3> 
                <p>
                  The body is not called if the count of <span class="keyword">try_put</span> calls received
                  becomes equal to the number of known predecessors as a result of this call. That
                  is, a call to <span class="keyword">remove_predecessor</span> will never invoke the body.
                </p>

              </div>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool register_successor( successor_type &amp;r )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>Adds <span class="keyword">r</span> to the set of successors.</p>

              <p><strong>Returns</strong>: <span class="keyword">true</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool remove_successor( successor_type &amp;r )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>Removes <span class="keyword">r</span> from the set of successors.</p>

              <p><strong>Returns</strong>: <span class="keyword">true</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool try_get( output_type &amp;v )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                The <span class="keyword">continue_node</span> does not contain buffering. Therefore it always
                rejects <span class="keyword">try_get</span> calls.
              </p>

              <p><strong>Returns</strong>: <span class="keyword">false</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 "><span class="keyword">bool try_reserve( output_type &amp;v )</span></td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                The <span class="keyword">continue_node</span> does not contain buffering.  Therefore it
                cannot be reserved.
              </p>

              <p><strong>Returns</strong>: <span class="keyword">false</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 ">
              <span class="keyword">bool try_release( )</span>
            </td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                The <span class="keyword">continue_node</span> does not contain buffering.  Therefore it
                cannot be reserved.
              </p>

              <p><strong>Returns</strong>: <span class="keyword">false</span></p>

            </td>

          </tr>

          <tr>
            <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d70557e288 "><span class="keyword">bool try_consume( )</span></td>

            <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d70557e291 ">
              <p>
                The <span class="keyword">continue_node</span> does not contain buffering.  Therefore it
                cannot be reserved.
              </p>

              <p><strong>Returns</strong>: <span class="keyword">false</span></p>

            </td>

          </tr>

        </tbody>

      </table>
</div>

  </div>

  <div class="section">
    <p>
      If the compiler supports class template argument deduction (C++17) then template arguments can
      be deduced automatically where possible. For example, the type of the node
    </p>

<pre>
continue_node c(g,
    [](const continue_msg &amp;msg) {
        return <span class="color(blue)" style="color:blue"><strong>continue_msg</strong></span>();
    },
    <span class="color(blue)" style="color:blue"><strong>lightweight</strong></span>());</pre>
              <p>
                is deduced as
              </p>

<pre>
continue_node&lt;<span class="color(blue)" style="color:blue"><strong>continue_msg</strong></span>, <span class="color(blue)" style="color:blue"><strong>lightweight</strong></span>&gt;;
</pre>
  </div>

</div>


<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="../../reference/flow_graph/functional_nodes.html">Functional Nodes</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="make_edge_func.html">make_edge Template Function</a></div>
<div><a href="remove_edge_func.html">remove_edge Template Function</a></div>
<div><a href="copy_body_func.html">copy_body Template Function</a></div>
<div><a href="../task_scheduler/task_group_context.html">task_group_context</a></div>
<div><a href="../exceptions.html">Exceptions</a></div>
<div><a href="message_passing_protocol.html">Message Passing Protocol</a></div>
<div><a href="sender_and_buffer_policy.html">Sender and Buffer Policy</a></div>
<div><a href="dependency_flow_graph_example.html">Dependency Flow Graph</a></div>
<div><a href="lightweight_policy.html">Lightweight policy</a></div>
<div><a href="../appendices/preview_features/flow_graph/helper_functions_for_expressing_graphs.html">Helper Functions for Expressing Graphs</a></div></div></div>

</body>
</html>
