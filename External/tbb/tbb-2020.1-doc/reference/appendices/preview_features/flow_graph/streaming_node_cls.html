
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="DC.Type" content="reference" />
<meta name="DC.Title" content="streaming_node Template Class" />
<meta name="DC.subject" content="streaming_node Template Class" />
<meta name="keywords" content="streaming_node Template Class" />
<meta name="DC.Relation" scheme="URI" content="../../../../reference/appendices/preview_features/flow_graph_features.html" />
<meta name="DC.Relation" scheme="URI" content="opencl_node_cls.html" />
<meta name="DC.Relation" scheme="URI" content="async_msg_cls.html" />
<meta name="DC.Relation" scheme="URI" content="../../../flow_graph/async_node_cls.html" />
<meta name="DC.Relation" scheme="URI" content="../../../flow_graph/join_node_cls.html" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="streaming_node_cls" />
<meta name="DC.Language" content="en-US" />
<link rel="stylesheet" type="text/css" href="../../../../intel_css_styles.css" />
<title>streaming_node Template Class</title>
<script src="../../../../resources/prism/prism.js"><!----></script>
<xml>
<MSHelp:Attr xmlns:MSHelp="http://www.microsoft.com/MSHelp/" Name="DocSet" Value="Intel"></MSHelp:Attr>
<MSHelp:Attr xmlns:MSHelp="http://www.microsoft.com/MSHelp/" Name="Locale" Value="kbEnglish"></MSHelp:Attr>
<MSHelp:Attr xmlns:MSHelp="http://www.microsoft.com/MSHelp/" Name="TopicType" Value="kbReference"></MSHelp:Attr>
</xml>
<link href="../../../../resources/prism/prism.css" rel="stylesheet" />
</head>
<body id="streaming_node_cls">
 <!-- ==============(Start:NavScript)================= -->
 <script src="..\..\..\..\NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(4);</script>
 <!-- ==============(End:NavScript)================= -->



  <h1 class="topictitle1">streaming_node Template Class</h1>

  
  <div>
    <div class="section"><h2 class="sectiontitle">Summary</h2>
      
      <p>
        <samp class="codeph">streaming_node</samp> enables the use of streaming programming models that support
        submission of kernels and data to devices through queues. The class <samp class="codeph">streaming_node</samp>
        provides the interfaces that are needed to easily integrate the use of such models into a flow graph,
        allowing developers to use a graph to coordinate functions that execute on different devices or
        hardware resources in a heterogeneous platform. You must define the low-level details of an actual
        model being used by providing a Factory to the <samp class="codeph">streaming_node</samp>.
      </p>

      <p>
        <a href="opencl_node_cls.html">
            opencl_node
        </a>
        is an example of a model-specific <samp class="codeph">streaming_node</samp> that enables OpenCL* powered
        devices to be utilized and coordinated by a Flow Graph. Developers may also define custom factories
        to support different modules.
      </p>

      <p>The use of <samp class="codeph">streaming_node</samp> requires C++11 support.</p>

    </div>

    <div class="section"><h2 class="sectiontitle">Syntax</h2>
      
<pre>
template &lt; typename... Args &gt;
class streaming_node;
template &lt; typename... Ports, typename JP, typename Factory &gt;
class streaming_node &lt; tuple &lt; Ports... &gt;, JP, Factory &gt;;
</pre>
    </div>

    <div class="section"><h2 class="sectiontitle">Header</h2>
      
<pre>
#define TBB_PREVIEW_FLOW_GRAPH_FEATURES 1
#include "tbb/flow_graph.h"
</pre>
    </div>

    <div class="section"><h2 class="sectiontitle">Description</h2>
      
      <p>
        The class <samp class="codeph">streaming_node</samp> is a part of a larger flow graph based solution
        to support heterogeneous computing devices.
      </p>

      
<div class="tablenoborder"><table cellpadding="4" summary="" frame="border" border="1" cellspacing="0" rules="all"><span class="tabledesc">The terms used in this section are defined below.</span>
          
          
          <thead align="left">
            <tr>
              <th class="cellrowborder" valign="top" width="33.33333333333333%" id="d39031e111">Term </th>

              <th class="cellrowborder" valign="top" width="66.66666666666666%" id="d39031e114">Definition </th>

            </tr>

          </thead>

          <tbody>
            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e111 ">
                Factory
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e114 ">
                <p>
                  A concept that provides interfaces to upload input data to the device, run a kernel on the device and to provide all needed types.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e111 ">
                Device
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e114 ">
                <p>
                  A compute resource capable of executing a kernel.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e111 ">
                Kernel
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e114 ">
                <p>
                  The compute function to be executed on the device.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e111 ">
                Kernel Argument
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e114 ">
                <p>
                  The data that must be provided to the device in order to execute the kernel.
                </p>

                <p>
                  Arguments may be input, output or both.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e111 ">
                Kernel Range
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e114 ">
                <p>
                  The calculation range for a single kernel execution.
                </p>

              </td>

            </tr>

          </tbody>

        </table>
</div>

      <p>
        There are several basic principles in the <samp class="codeph">streaming_node</samp> usage model:
        <ul>
          <li>
            <p>
              Device specifics are not directly embedded in a <samp class="codeph">streaming_node</samp>,
              but are instead accessed through a Factory.
            </p>

          </li>

          <li>
            <p>
              A <samp class="codeph">streaming_node</samp> receives input data through its set of input ports.
            </p>

            <ul>
              <li>
                <p>
                  The input data may be used as kernel arguments, the kernel range, or may pass through
                  unmodified to an output port.
                </p>

              </li>

              <li>
                <p>
                  Depending on the Factory implementation, input messages that are derived from
                  <samp class="codeph">async_msg</samp> may be treated specially to enable asynchronous execution.
                </p>

              </li>

            </ul>

          </li>

          <li>
            <p>
              For each input port, there is a corresponding output port.
            </p>

            <ul>
              <li>
                <p>
                  All output messages are wrapped in Factory-defined <samp class="codeph">async_msg</samp> types
                  to enable asynchronous execution.
                </p>

              </li>

              <li>
                <p>
                  The availability of an output message does not mean that the underlying result data is
                  ready because all output messages are derived from <samp class="codeph">async_msg</samp>
                  (see <samp class="codeph">async_msg</samp>).
                </p>

              </li>

              <li>
                <p>
                  If the input from any port is not referenced by a kernel argument or the kernel range,
                  the input data will pass through unchanged to its matching output port.
                </p>

              </li>

            </ul>

          </li>

          <li>
            <p>
              While you are creating and setting up a <samp class="codeph">streaming_node</samp>, you can specify:
            </p>

            <ul>
              <li>
                <p>
                  Model specifics (through the Factory object)
                </p>

              </li>

              <li>
                <p>
                  A device selecting logic (through a <samp class="codeph">DeviceSelector</samp> object)
                </p>

              </li>

              <li>
                <p>
                  The kernel arguments as constants or as mapped from specific input ports
                </p>

              </li>

              <li>
                <p>
                  Optionally, the kernel range as a constant or as mapped from a specific input port
                </p>

              </li>

            </ul>

          </li>

        </ul>

      </p>

      <div class="fignone" id="fig1_streaming_node"><span class="figcap">
          A diagram of a <samp class="codeph">streaming_node</samp> is shown below:
        </span>
        
        <br /><div class="imagecenter"><img src="../../../Resources/streaming_node_args.png" height="372" width="654" alt="A diagram of a streaming_node" align="center" /></div><br />
      </div>

      <div class="fignone" id="fig2_streaming_node"><span class="figcap">
          The node can read the kernel arguments (and the optional kernel range)
          from the input ports. Or you can define the kernel arguments (and the range)
          once before using the node.
        </span>
        
        <br /><div class="imagecenter"><img src="../../../Resources/streaming_node_port_refs.png" height="372" width="654" alt="The node can be read the kernel arguments and the kernel range from input ports." align="center" /></div><br />
      </div>

      <p>
        The output data may not be ready immediately at the end of the node execution, so output ports
        always send messages that are derived from <samp class="codeph">async_msg</samp>.
        However the capabilities of the <samp class="codeph">async_msg</samp> class ensure that other flow graph
        nodes properly respond to these messages and do not try to use the data before it is available
        (see <samp class="codeph">async_msg</samp>).
      </p>

      <p>
        The simplified <samp class="codeph">streaming_node</samp> algorithm can be described as the following series
        of actions:
        <ul>
          <li>
            <p>
              Receive input data at the input ports. If not already wrapped in the Factory-specific
              <samp class="codeph">async_msg</samp> type, wrap the inputs.
            </p>

          </li>

          <li>
            <p>
              Select a device for the kernel execution.
            </p>

          </li>

          <li>
            <p>
              Send the kernel arguments and, optionally, the kernel range to the device.
            </p>

          </li>

          <li>
            <p>
              Enqueue the kernel for execution on the device.
            </p>

          </li>

          <li>
            <p>
              Update the dependencies in the <samp class="codeph">async_msgs</samp> as needed.
            </p>

          </li>

          <li>
            <p>
              Send the updated <samp class="codeph">async_msgs</samp> through the output ports as the node output.
            </p>

          </li>

        </ul>

      </p>

      <div class="Note"><h3 class="NoteTipHead">Note</h3> 
        <p>
          A <samp class="codeph">streaming_node</samp> always sends out <samp class="codeph">async_msg_type</samp> values to
          the next nodes. It does NOT wait for the end of the kernel execution. The waiting is postponed
          to the point of real result data processing, like in the general C++ future-promise concept.
          (See description of the <samp class="codeph">async_msg</samp> class for details.)
        </p>

      </div>

      <div class="Note"><h3 class="NoteTipHead">Note</h3> 
        <p>
          The node assumes that all kernel arguments may be modified by the execution of a kernel in the
          factory. This assumption may unnecessarily delay the availability of the data in read-only arguments
          in the output <samp class="codeph">async_msgs</samp>.
        </p>

      </div>

    </div>

    <div class="section"><h2 class="sectiontitle">Factory Concept</h2>
      
      <p>
        <strong>Summary</strong>
      </p>

      <p>
        The <samp class="codeph">streaming_node</samp> is an abstract execution mechanism that communicates
        with a particular device through a factory object. The Factory provides the means
        to upload input data to the device, run a kernel on the device and to provide a set of
        needed by the node types.
      </p>

      <p>
        <strong>Requirements</strong>
      </p>

      <p>
        The following table lists the requirements for a Factory type <samp class="codeph">F</samp>.
      </p>

      
<div class="tablenoborder"><table cellpadding="4" summary="" id="tbl1" width="100%" frame="hsides" border="1" rules="all"><caption><span class="tablecap">Factory Concept</span></caption>
        <thead align="left">
         <tr>
          <th class="cellrowborder" valign="top" width="50%" id="d39031e473">
            <p>
              Pseudo-Signature
            </p>

          </th>

          <th class="row-nocellborder" valign="top" width="50%" id="d39031e479">
            <p>
              Semantics
            </p>

          </th>

         </tr>
</thead>

        <tbody>
         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> template &lt;typename T&gt;</samp>
            </p>

            <p>
              <samp class="codeph"> using F::<strong>async_msg_type</strong> = .....;</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              Device specific type: async message type (derived from <samp class="codeph">async_msg</samp> class).
            </p>

          </td>

         </tr>

         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> typedef ..... F::<strong>device_type</strong>;</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              Device specific type: target device type.
            </p>

          </td>

         </tr>

         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> typedef ..... F::<strong>kernel_type</strong>;</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              Device specific type: device kernel type.
            </p>

          </td>

         </tr>

         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> typedef ..... F::<strong>range_type</strong>;</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              <strong>Optional</strong>. Device specific type: range type.
            </p>

          </td>

         </tr>

         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> template &lt;typename ...Args&gt;</samp>
            </p>

            <p>
              <samp class="codeph"> void F::<strong>send_kernel</strong>(device_type device, const kernel_type&amp; kernel, [const range_type&amp; work_size,] Args&amp;... args)</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              Run kernel on the device.
            </p>

          </td>

         </tr>

         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> template &lt;typename ...Args&gt;</samp>
            </p>

            <p>
              <samp class="codeph"> void F::<strong>send_data</strong>(device_type device, Args&amp;... args)</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              Upload data to the device.
            </p>

          </td>

         </tr>

         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e473 ">
            <p>
              <samp class="codeph"> template &lt;typename FinalizeFn, typename ...Args&gt;</samp>
            </p>

            <p>
              <samp class="codeph"> void F::<strong>finalize</strong>(device_type device, FinalizeFn fn, Args&amp;... args)</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e479 ">
            <p>
              Finalization action after the kernel run.
            </p>

            <p>
              The functor <samp class="codeph">fn</samp> must be called after the end of the kernel execution.
            </p>

          </td>

         </tr>

        </tbody>

      </table>
</div>

      <p>
        If the Factory supports the range concept, the type <samp class="codeph">range_type</samp> must be defined.
        In this case, <samp class="codeph">streaming_node</samp> provides a set of methods to define the range.
        If kernel ranges are not supported by the Factory, these methods are unavailable.
      </p>

      <p>
        If a kernel range is not supported, the <samp class="codeph">send_kernel</samp> interface is as follows:
      </p>

<pre>
template &lt;typename ...Args&gt;
void F::<strong>send_kernel</strong>(device_type device, const kernel_type&amp; kernel, Args&amp;... args)
</pre>
      <p>
        <strong>Description</strong>
      </p>

      <p>
        The streaming node calls the method <strong><samp class="codeph">send_kernel</samp></strong> to start the kernel
        on the specified external device. All incoming arguments (<samp class="codeph">Args&amp;... args</samp>) are
        provided as references to the <samp class="codeph">async_msg_type</samp> type. The references are constant
        if the arguments were set by values via <strong><samp class="codeph">set_args</samp></strong> or a non-constant
        if the arguments are dynamic values from input ports; that is, was set originally via a
        <samp class="codeph">port_ref</samp> arguments of the <strong><samp class="codeph">set_args</samp></strong> method.
      </p>

      <p>
        The method <strong><samp class="codeph">send_data</samp></strong> is called by the streaming node to upload original
        kernel arguments to the specified device. All incoming arguments <samp class="codeph">Args&amp;... args</samp>
        are provided as references to the <samp class="codeph">async_msg_type</samp> type. The list includes only values
        that were set via <strong><samp class="codeph">set_args</samp></strong> by value (not as a <samp class="codeph">port_ref</samp>).
      </p>

      <p>
        The method <strong><samp class="codeph">finalize</samp></strong> is called by the streaming node to let the factory set a
        callback for the graph to notify the graph that the kernel execution is finished. In this case the
        factory must call the provided finalization functor. Note that the method <strong><samp class="codeph">finalize</samp></strong>
        will be called by the node only if the following graph nodes rejected this node output messages
        or if the node output ports are <strong>not</strong> connected with a node (so, nothing in the graph
        will wait for the kernel results). The incoming arguments <samp class="codeph">Args&amp;... args</samp> are
        provided as either constant or non-constant references to the <samp class="codeph">async_msg_type</samp> type as
        in the method <strong><samp class="codeph">send_kernel</samp></strong>.
      </p>

    </div>

    <div class="section"><h2 class="sectiontitle">Device Selector Concept</h2>
      
      <p>
        <strong>Summary</strong>
      </p>

      <p>
        The <samp class="codeph">Device Selector</samp> object is a simple user functor that selects one device
        from those available to the Factory instance.
      </p>

      <p>
        <strong>Requirements</strong>
      </p>

      <p>
        The following table lists the requirements for a Device Selector type <samp class="codeph">DS</samp>.
      </p>

      
<div class="tablenoborder"><table cellpadding="4" summary="" id="tbl2" width="100%" frame="hsides" border="1" rules="all"><caption><span class="tablecap">Device Selector Concept</span></caption>
        <thead align="left">
         <tr>
          <th class="cellrowborder" valign="top" width="50%" id="d39031e818">
            <p>
              Pseudo-Signature
            </p>

          </th>

          <th class="row-nocellborder" valign="top" width="50%" id="d39031e824">
            <p>
              Semantics
            </p>

          </th>

         </tr>
</thead>

        <tbody>
         <tr valign="top">
          <td class="cellrowborder" valign="top" width="50%" headers="d39031e818 ">
            <p>
              <samp class="codeph"> device_type DS::<strong>operator()</strong>( factory&amp; f )</samp>
            </p>

          </td>

          <td class="row-nocellborder" valign="top" width="50%" headers="d39031e824 ">
            <p>
              Get a device from the Factory. The node starts a kernel execution on the device.
            </p>

          </td>

         </tr>

        </tbody>

      </table>
</div>

      <p>
        <strong>Example</strong>
      </p>

<pre>
struct external_device_selector {
    device_type operator()( factory&amp; f ) {
        return f.<em>get_somehow_an_available_device()</em>;
    }
};
</pre>
      <div class="Note"><h3 class="NoteTipHead">Note</h3> 
        <p>
          The device type is defined by the factory.
        </p>

      </div>

    </div>

    <div class="section"><h2 class="sectiontitle">Port-reference usage</h2>
      
      <p>
        The <samp class="codeph">streaming_node</samp> user can provide kernel arguments and, optionally,
        a kernel range argument as constant values or map input ports to these arguments.
      </p>

      <p>
        If the Factory supports a kernel range, you can use the following methods of
        the <samp class="codeph">streaming_node</samp> class to set the range value:
      </p>

<pre>
void set_range(const range_type&amp; work_size);

void set_range(range_type&amp;&amp; work_size);
</pre>
      <p>
        To set the kernel arguments as a set of constants, you can use the following method
        in the <samp class="codeph">streaming_node</samp> class:
      </p>

<pre>
template &lt;typename ...Args&gt;
void set_args( Args&amp;&amp;... args );
</pre>
      <p>
        <strong>Example</strong>
      </p>

<pre>
node.set_range( {{ width, height }} );
node.set_args(/* stride_x */ 1, /* stride_y */ 0, /* stride_z */ 0, /* dim */ 1 );
</pre>
      <p>
        You can use the following methods of the streaming node class to map the input ports
        to kernel arguments and, if supported, the kernel range:
      </p>

<pre>
void set_range( <em>port_ref_entity</em> );

template &lt;typename ...Args&gt;
void set_args( Args&amp;&amp;... args ) ; // args can include <em>port_ref_entity(s)</em>
</pre>
      <p>
        Where <em>port_ref_entity</em> can be returned by any helper from the list below:
        <ul>
          <li>
            <p>
              <samp class="codeph">port_ref&lt;N&gt;</samp>
            </p>

          </li>

          <li>
            <p>
              <samp class="codeph">port_ref&lt;N1, N2&gt;</samp>
            </p>

          </li>

          <li>
            <p>
              <samp class="codeph">port_ref&lt;N&gt;()</samp>
            </p>

          </li>

          <li>
            <p>
              <samp class="codeph">port_ref&lt;N1, N2&gt;()</samp>
            </p>

          </li>

        </ul>

      </p>

      <p>
        <strong>Example</strong>
      </p>

<pre>
node.set_range( port_ref&lt;2&gt; );
node.set_args( port_ref&lt;0, 1&gt; );
</pre>
      <p>
        or
      </p>

<pre>
node.set_range( port_ref&lt;2&gt;() );
node.set_args( port_ref&lt;0, 1&gt;() );
</pre>
      <p>
        or
      </p>

<pre>
node.set_range( port_ref&lt;2&gt; );
node.set_args( port_ref&lt;0, 1&gt;() );
</pre>
      <p>
        The approaches can be easily mixed.
      </p>

      <p>
        <strong>Example</strong>
      </p>

<pre>
node.set_range( port_ref&lt;2&gt; );
node.set_args( port_ref&lt;0, 1&gt;(), /* stride_x */ 1, /* stride_y */ 0, /* stride_z */ 0, /* dim */ 1 );
</pre>
      <p>
        In the example above, the range is coming from port 2, while the data from
        ports 0 and 1 will be sent to the device as the kernel arguments together
        with the predefined constant arguments (stride_x, stride_y, etc.).
      </p>

    </div>

    <div class="section"><h2 class="sectiontitle">Example</h2>
      
      <p>
        The implementation of the class <samp class="codeph">opencl_node</samp> is an example
        use of the class <samp class="codeph">streaming_node</samp>.
      </p>

      <p>
        For details, see:
        https://software.intel.com/en-us/blogs/2015/12/09/opencl-node-overview
      </p>

    </div>

    <div class="section"><h2 class="sectiontitle">Public members</h2>
      
<pre>
namespace tbb {
namespace flow {

template&lt;typename... Args&gt;
class streaming_node;

template&lt;typename... Ports, typename JP, typename Factory&gt;
class streaming_node&lt; tuple&lt;Ports...&gt;, JP, Factory &gt; : ..... {
public:
    template &lt;typename DeviceSelector&gt;
    streaming_node( graph&amp; g, const kernel_type&amp; kernel, DeviceSelector d, Factory&amp; f );

    streaming_node( const streaming_node&amp; node );

    streaming_node( streaming_node&amp;&amp; node );

    ~streaming_node() ;

    template &lt;typename... Args&gt;
    void set_args( Args&amp;&amp;... args ) ;

    // The following methods are available only if
    // the Factory::range_type is defined:
    void set_range(const range_type&amp; work_size);

    void set_range(range_type&amp;&amp; work_size);

    template &lt;int N&gt;
    void set_range(port_ref_impl&lt;N, N&gt;);

    template &lt;int N&gt;
    void set_range(port_ref_impl&lt;N, N&gt;(*)());

};

}
}
</pre>
      
<div class="tablenoborder"><table cellpadding="4" summary="" frame="border" border="1" cellspacing="0" rules="all"><span class="tabledesc">The following table provides additional information on the members of this template class.</span>
          
          
          <thead align="left">
            <tr>
              <th class="cellrowborder" valign="top" width="33.33333333333333%" id="d39031e1052">Member </th>

              <th class="cellrowborder" valign="top" width="66.66666666666666%" id="d39031e1055">Description </th>

            </tr>

          </thead>

          <tbody>
            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">typename... Ports</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  The node's incoming data types.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">typename JP</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Join Policy. See the description of the class <samp class="codeph">join_node</samp> for details.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">typename Factory</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  The device specific Factory type.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">template &lt;typename DeviceSelector&gt; streaming_node( graph&amp; g, const kernel_type&amp; kernel, DeviceSelector d, Factory&amp; f );</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Main constructor.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">streaming_node( const streaming_node&amp; node );</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Copy constructor.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">streaming_node( streaming_node&amp;&amp; node );</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Move constructor.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">~streaming_node();</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Destructor.
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">template &lt;typename... Args&gt; void set_args( Args&amp;&amp;... args );</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Set the arguments for the kernel executions (the arguments can include values and/or port-refs).
                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">void set_range(const range_type&amp; work_size);</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Set a constant range for the kernel runs.
                  <div class="Note"><h3 class="NoteTipHead">Note</h3> 
                    <p>
                      The method is available only if the <samp class="codeph">Factory::range_type</samp> is defined.
                    </p>

                  </div>

                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">void set_range(range_type&amp;&amp; work_size);</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Same as the method above but with move semantic.
                  <div class="Note"><h3 class="NoteTipHead">Note</h3> 
                    <p>
                      The method is available only if the <samp class="codeph">Factory::range_type</samp> is defined.
                    </p>

                  </div>

                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">template &lt;int N&gt; void set_range(port_ref_impl&lt;N, N&gt;);</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Set port-ref for the range to get the range value dynamically from the N-th port.
                  <div class="Note"><h3 class="NoteTipHead">Note</h3> 
                    <p>
                      The  method is available only if the <samp class="codeph">Factory::range_type</samp> is defined.
                    </p>

                  </div>

                </p>

              </td>

            </tr>

            <tr>
              <td class="cellrowborder" valign="top" width="33.33333333333333%" headers="d39031e1052 ">
                <samp class="codeph">template &lt;int N&gt; void set_range(port_ref_impl&lt;N, N&gt;(*)());</samp>
              </td>

              <td class="cellrowborder" valign="top" width="66.66666666666666%" headers="d39031e1055 ">
                <p>
                  Set port-ref for the range to get the range value dynamically from the N-th port.
                  <div class="Note"><h3 class="NoteTipHead">Note</h3> 
                    <p>
                      The  method is available only if the <samp class="codeph">Factory::range_type</samp> is defined.
                    </p>

                  </div>

                </p>

              </td>

            </tr>

          </tbody>

        </table>
</div>

    </div>

  </div>

  
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="../../../../reference/appendices/preview_features/flow_graph_features.html">Flow Graph</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="opencl_node_cls.html">opencl_node</a></div>
<div><a href="async_msg_cls.html">async_msg</a></div>
<div><a href="../../../flow_graph/async_node_cls.html">async_node</a></div>
<div><a href="../../../flow_graph/join_node_cls.html">join_node</a></div></div></div>

</body>
</html>
